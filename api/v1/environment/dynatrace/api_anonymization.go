/*
 * Dynatrace Environment API
 *
 * Documentation of the Dynatrace Environment API v1. To read about use cases and examples, refer to the [help page](https://dt-url.net/xc03k3c).  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dynatrace

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// AnonymizationApiService AnonymizationApi service
type AnonymizationApiService service

type ApiAnonymizeRequest struct {
	ctx _context.Context
	ApiService *AnonymizationApiService
	startTimestamp *int64
	endTimestamp *int64
	userIds *[]string
	ips *[]string
	additionalField *[]string
}

func (r ApiAnonymizeRequest) StartTimestamp(startTimestamp int64) ApiAnonymizeRequest {
	r.startTimestamp = &startTimestamp
	return r
}
func (r ApiAnonymizeRequest) EndTimestamp(endTimestamp int64) ApiAnonymizeRequest {
	r.endTimestamp = &endTimestamp
	return r
}
func (r ApiAnonymizeRequest) UserIds(userIds []string) ApiAnonymizeRequest {
	r.userIds = &userIds
	return r
}
func (r ApiAnonymizeRequest) Ips(ips []string) ApiAnonymizeRequest {
	r.ips = &ips
	return r
}
func (r ApiAnonymizeRequest) AdditionalField(additionalField []string) ApiAnonymizeRequest {
	r.additionalField = &additionalField
	return r
}

func (r ApiAnonymizeRequest) Execute() (AnonymizationIdResult, *_nethttp.Response, error) {
	return r.ApiService.AnonymizeExecute(r)
}

/*
 * Anonymize Creates user session anonymization job
 * The job anonymizes all user sessions in the specified timeframe by masking the specified fields. 

To identify user sessions to be anonymized you can specify either userID, or IP address, or both. If you specify both the **OR** logic applies. 

You can't undo the anonymization.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiAnonymizeRequest
 */
func (a *AnonymizationApiService) Anonymize(ctx _context.Context) ApiAnonymizeRequest {
	return ApiAnonymizeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return AnonymizationIdResult
 */
func (a *AnonymizationApiService) AnonymizeExecute(r ApiAnonymizeRequest) (AnonymizationIdResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnonymizationIdResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnonymizationApiService.Anonymize")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/anonymize/anonymizationJobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.startTimestamp != nil {
		localVarQueryParams.Add("startTimestamp", parameterToString(*r.startTimestamp, ""))
	}
	if r.endTimestamp != nil {
		localVarQueryParams.Add("endTimestamp", parameterToString(*r.endTimestamp, ""))
	}
	if r.userIds != nil {
		t := *r.userIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("userIds", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("userIds", parameterToString(t, "multi"))
		}
	}
	if r.ips != nil {
		t := *r.ips
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("ips", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("ips", parameterToString(t, "multi"))
		}
	}
	if r.additionalField != nil {
		t := *r.additionalField
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("additionalField", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("additionalField", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatusRequest struct {
	ctx _context.Context
	ApiService *AnonymizationApiService
	requestId string
}


func (r ApiGetStatusRequest) Execute() (AnonymizationProgressResult, *_nethttp.Response, error) {
	return r.ApiService.GetStatusExecute(r)
}

/*
 * GetStatus Shows the progress of the specified anonymization job
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param requestId The ID of the required anonymization job.
 * @return ApiGetStatusRequest
 */
func (a *AnonymizationApiService) GetStatus(ctx _context.Context, requestId string) ApiGetStatusRequest {
	return ApiGetStatusRequest{
		ApiService: a,
		ctx: ctx,
		requestId: requestId,
	}
}

/*
 * Execute executes the request
 * @return AnonymizationProgressResult
 */
func (a *AnonymizationApiService) GetStatusExecute(r ApiGetStatusRequest) (AnonymizationProgressResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AnonymizationProgressResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnonymizationApiService.GetStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/anonymize/anonymizationJobs/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", _neturl.PathEscape(parameterToString(r.requestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
