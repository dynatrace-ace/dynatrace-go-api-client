/*
 * Dynatrace Configuration API
 *
 * Documentation of the Dynatrace Configuration API. Refer to the [help page](https://www.dynatrace.com/support/help/shortlink/config-api) to read about use-cases and examples.  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dynatrace

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ServiceDetectionOpaqueAndExternalWebServiceApiService ServiceDetectionOpaqueAndExternalWebServiceApi service
type ServiceDetectionOpaqueAndExternalWebServiceApiService service

type ApiCreateOpaqueAndExternalWebServiceRuleRequest struct {
	ctx _context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebServiceApiService
	position *string
	opaqueAndExternalWebServiceRule *OpaqueAndExternalWebServiceRule
}

func (r ApiCreateOpaqueAndExternalWebServiceRuleRequest) Position(position string) ApiCreateOpaqueAndExternalWebServiceRuleRequest {
	r.position = &position
	return r
}
func (r ApiCreateOpaqueAndExternalWebServiceRuleRequest) OpaqueAndExternalWebServiceRule(opaqueAndExternalWebServiceRule OpaqueAndExternalWebServiceRule) ApiCreateOpaqueAndExternalWebServiceRuleRequest {
	r.opaqueAndExternalWebServiceRule = &opaqueAndExternalWebServiceRule
	return r
}

func (r ApiCreateOpaqueAndExternalWebServiceRuleRequest) Execute() (EntityShortRepresentation, *_nethttp.Response, error) {
	return r.ApiService.CreateOpaqueAndExternalWebServiceRuleExecute(r)
}

/*
 * CreateOpaqueAndExternalWebServiceRule Creates a new service detection rule | maturity=EARLY_ADOPTER
 * The body must not provide an ID as it will be automatically assigned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateOpaqueAndExternalWebServiceRuleRequest
 */
func (a *ServiceDetectionOpaqueAndExternalWebServiceApiService) CreateOpaqueAndExternalWebServiceRule(ctx _context.Context) ApiCreateOpaqueAndExternalWebServiceRuleRequest {
	return ApiCreateOpaqueAndExternalWebServiceRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return EntityShortRepresentation
 */
func (a *ServiceDetectionOpaqueAndExternalWebServiceApiService) CreateOpaqueAndExternalWebServiceRuleExecute(r ApiCreateOpaqueAndExternalWebServiceRuleRequest) (EntityShortRepresentation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EntityShortRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebServiceApiService.CreateOpaqueAndExternalWebServiceRule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_SERVICE"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.position != nil {
		localVarQueryParams.Add("position", parameterToString(*r.position, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opaqueAndExternalWebServiceRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOpaqueAndExternalWebServiceRuleRequest struct {
	ctx _context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebServiceApiService
	id string
}


func (r ApiDeleteOpaqueAndExternalWebServiceRuleRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteOpaqueAndExternalWebServiceRuleExecute(r)
}

/*
 * DeleteOpaqueAndExternalWebServiceRule Deletes the specified service detection rule | maturity=EARLY_ADOPTER
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the service detection rule to be deleted.
 * @return ApiDeleteOpaqueAndExternalWebServiceRuleRequest
 */
func (a *ServiceDetectionOpaqueAndExternalWebServiceApiService) DeleteOpaqueAndExternalWebServiceRule(ctx _context.Context, id string) ApiDeleteOpaqueAndExternalWebServiceRuleRequest {
	return ApiDeleteOpaqueAndExternalWebServiceRuleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *ServiceDetectionOpaqueAndExternalWebServiceApiService) DeleteOpaqueAndExternalWebServiceRuleExecute(r ApiDeleteOpaqueAndExternalWebServiceRuleRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebServiceApiService.DeleteOpaqueAndExternalWebServiceRule")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_SERVICE/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetOpaqueAndExternalWebServiceRuleRequest struct {
	ctx _context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebServiceApiService
	id string
}


func (r ApiGetOpaqueAndExternalWebServiceRuleRequest) Execute() (OpaqueAndExternalWebServiceRule, *_nethttp.Response, error) {
	return r.ApiService.GetOpaqueAndExternalWebServiceRuleExecute(r)
}

/*
 * GetOpaqueAndExternalWebServiceRule Shows the properties of the specified service detection rule | maturity=EARLY_ADOPTER
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the required service detection rule.
 * @return ApiGetOpaqueAndExternalWebServiceRuleRequest
 */
func (a *ServiceDetectionOpaqueAndExternalWebServiceApiService) GetOpaqueAndExternalWebServiceRule(ctx _context.Context, id string) ApiGetOpaqueAndExternalWebServiceRuleRequest {
	return ApiGetOpaqueAndExternalWebServiceRuleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return OpaqueAndExternalWebServiceRule
 */
func (a *ServiceDetectionOpaqueAndExternalWebServiceApiService) GetOpaqueAndExternalWebServiceRuleExecute(r ApiGetOpaqueAndExternalWebServiceRuleRequest) (OpaqueAndExternalWebServiceRule, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OpaqueAndExternalWebServiceRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebServiceApiService.GetOpaqueAndExternalWebServiceRule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_SERVICE/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOpaqueAndExternalWebServiceRulesRequest struct {
	ctx _context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebServiceApiService
}


func (r ApiListOpaqueAndExternalWebServiceRulesRequest) Execute() (StubList, *_nethttp.Response, error) {
	return r.ApiService.ListOpaqueAndExternalWebServiceRulesExecute(r)
}

/*
 * ListOpaqueAndExternalWebServiceRules Lists all opaque and external web service detection rules | maturity=EARLY_ADOPTER
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListOpaqueAndExternalWebServiceRulesRequest
 */
func (a *ServiceDetectionOpaqueAndExternalWebServiceApiService) ListOpaqueAndExternalWebServiceRules(ctx _context.Context) ApiListOpaqueAndExternalWebServiceRulesRequest {
	return ApiListOpaqueAndExternalWebServiceRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return StubList
 */
func (a *ServiceDetectionOpaqueAndExternalWebServiceApiService) ListOpaqueAndExternalWebServiceRulesExecute(r ApiListOpaqueAndExternalWebServiceRulesRequest) (StubList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  StubList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebServiceApiService.ListOpaqueAndExternalWebServiceRules")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_SERVICE"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderOpaqueAndExternalWebServiceRulesRequest struct {
	ctx _context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebServiceApiService
	stubList *StubList
}

func (r ApiOrderOpaqueAndExternalWebServiceRulesRequest) StubList(stubList StubList) ApiOrderOpaqueAndExternalWebServiceRulesRequest {
	r.stubList = &stubList
	return r
}

func (r ApiOrderOpaqueAndExternalWebServiceRulesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrderOpaqueAndExternalWebServiceRulesExecute(r)
}

/*
 * OrderOpaqueAndExternalWebServiceRules Reorders the service detection rules of the specified type | maturity=EARLY_ADOPTER
 * The request reorders the rules of the specified type according to the order of the IDs in the body of the request. 

 Rules that are omitted in the body of the request will retain their relative order but will be placed *after* all those present in the request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiOrderOpaqueAndExternalWebServiceRulesRequest
 */
func (a *ServiceDetectionOpaqueAndExternalWebServiceApiService) OrderOpaqueAndExternalWebServiceRules(ctx _context.Context) ApiOrderOpaqueAndExternalWebServiceRulesRequest {
	return ApiOrderOpaqueAndExternalWebServiceRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *ServiceDetectionOpaqueAndExternalWebServiceApiService) OrderOpaqueAndExternalWebServiceRulesExecute(r ApiOrderOpaqueAndExternalWebServiceRulesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebServiceApiService.OrderOpaqueAndExternalWebServiceRules")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_SERVICE/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stubList
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateOpaqueAndExternalWebServiceRuleRequest struct {
	ctx _context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebServiceApiService
	id string
	opaqueAndExternalWebServiceRule *OpaqueAndExternalWebServiceRule
}

func (r ApiUpdateOpaqueAndExternalWebServiceRuleRequest) OpaqueAndExternalWebServiceRule(opaqueAndExternalWebServiceRule OpaqueAndExternalWebServiceRule) ApiUpdateOpaqueAndExternalWebServiceRuleRequest {
	r.opaqueAndExternalWebServiceRule = &opaqueAndExternalWebServiceRule
	return r
}

func (r ApiUpdateOpaqueAndExternalWebServiceRuleRequest) Execute() (EntityShortRepresentation, *_nethttp.Response, error) {
	return r.ApiService.UpdateOpaqueAndExternalWebServiceRuleExecute(r)
}

/*
 * UpdateOpaqueAndExternalWebServiceRule Updates an existing service detection rule | maturity=EARLY_ADOPTER
 * If the rule with the specified ID doesn't exist, a new rule will be created and appended to the end of the rule list. 

 The request keeps an existing order of rules, unless the **order** parameter is set.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the rule to be updated.
 * @return ApiUpdateOpaqueAndExternalWebServiceRuleRequest
 */
func (a *ServiceDetectionOpaqueAndExternalWebServiceApiService) UpdateOpaqueAndExternalWebServiceRule(ctx _context.Context, id string) ApiUpdateOpaqueAndExternalWebServiceRuleRequest {
	return ApiUpdateOpaqueAndExternalWebServiceRuleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return EntityShortRepresentation
 */
func (a *ServiceDetectionOpaqueAndExternalWebServiceApiService) UpdateOpaqueAndExternalWebServiceRuleExecute(r ApiUpdateOpaqueAndExternalWebServiceRuleRequest) (EntityShortRepresentation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EntityShortRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebServiceApiService.UpdateOpaqueAndExternalWebServiceRule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_SERVICE/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opaqueAndExternalWebServiceRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateCreateOpaqueAndExternalWebServiceRuleRequest struct {
	ctx _context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebServiceApiService
	opaqueAndExternalWebServiceRule *OpaqueAndExternalWebServiceRule
}

func (r ApiValidateCreateOpaqueAndExternalWebServiceRuleRequest) OpaqueAndExternalWebServiceRule(opaqueAndExternalWebServiceRule OpaqueAndExternalWebServiceRule) ApiValidateCreateOpaqueAndExternalWebServiceRuleRequest {
	r.opaqueAndExternalWebServiceRule = &opaqueAndExternalWebServiceRule
	return r
}

func (r ApiValidateCreateOpaqueAndExternalWebServiceRuleRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ValidateCreateOpaqueAndExternalWebServiceRuleExecute(r)
}

/*
 * ValidateCreateOpaqueAndExternalWebServiceRule Validates the payload for the `POST /ruleBasedServiceDetection/OPAQUE_AND_EXTERNAL_WEB_SERVICE` request | maturity=EARLY_ADOPTER
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiValidateCreateOpaqueAndExternalWebServiceRuleRequest
 */
func (a *ServiceDetectionOpaqueAndExternalWebServiceApiService) ValidateCreateOpaqueAndExternalWebServiceRule(ctx _context.Context) ApiValidateCreateOpaqueAndExternalWebServiceRuleRequest {
	return ApiValidateCreateOpaqueAndExternalWebServiceRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *ServiceDetectionOpaqueAndExternalWebServiceApiService) ValidateCreateOpaqueAndExternalWebServiceRuleExecute(r ApiValidateCreateOpaqueAndExternalWebServiceRuleRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebServiceApiService.ValidateCreateOpaqueAndExternalWebServiceRule")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_SERVICE/validator"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.opaqueAndExternalWebServiceRule == nil {
		return nil, reportError("opaqueAndExternalWebServiceRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opaqueAndExternalWebServiceRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidateUpdateOpaqueAndExternalWebServiceRuleRequest struct {
	ctx _context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebServiceApiService
	id string
	opaqueAndExternalWebServiceRule *OpaqueAndExternalWebServiceRule
}

func (r ApiValidateUpdateOpaqueAndExternalWebServiceRuleRequest) OpaqueAndExternalWebServiceRule(opaqueAndExternalWebServiceRule OpaqueAndExternalWebServiceRule) ApiValidateUpdateOpaqueAndExternalWebServiceRuleRequest {
	r.opaqueAndExternalWebServiceRule = &opaqueAndExternalWebServiceRule
	return r
}

func (r ApiValidateUpdateOpaqueAndExternalWebServiceRuleRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ValidateUpdateOpaqueAndExternalWebServiceRuleExecute(r)
}

/*
 * ValidateUpdateOpaqueAndExternalWebServiceRule Validate the payload for the `PUT /ruleBasedServiceDetection/OPAQUE_AND_EXTERNAL_WEB_SERVICE/{id}` request | maturity=EARLY_ADOPTER
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the service detection rule to be validated.
 * @return ApiValidateUpdateOpaqueAndExternalWebServiceRuleRequest
 */
func (a *ServiceDetectionOpaqueAndExternalWebServiceApiService) ValidateUpdateOpaqueAndExternalWebServiceRule(ctx _context.Context, id string) ApiValidateUpdateOpaqueAndExternalWebServiceRuleRequest {
	return ApiValidateUpdateOpaqueAndExternalWebServiceRuleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *ServiceDetectionOpaqueAndExternalWebServiceApiService) ValidateUpdateOpaqueAndExternalWebServiceRuleExecute(r ApiValidateUpdateOpaqueAndExternalWebServiceRuleRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebServiceApiService.ValidateUpdateOpaqueAndExternalWebServiceRule")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_SERVICE/{id}/validator"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.opaqueAndExternalWebServiceRule == nil {
		return nil, reportError("opaqueAndExternalWebServiceRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opaqueAndExternalWebServiceRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
