/*
 * Dynatrace Configuration API
 *
 * Documentation of the Dynatrace Configuration API. Refer to the [help page](https://www.dynatrace.com/support/help/shortlink/config-api) to read about use-cases and examples.  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dynatrace

import (
	"encoding/json"
)

// Scope The scope of the maintenance window.    The scope restricts the alert/problem detection suppression to certain Dynatrace entities. It can contain a list of entities and/or matching rules for dynamic formation of the scope.    If no scope is specified, the alert/problem detection suppression applies to the entire environment.
type Scope struct {
	// A list of Dynatrace entities (for example, hosts or services) to be included in the scope.   Allowed values are Dynatrace entity IDs.
	Entities []string `json:"entities"`
	// A list of matching rules for dynamic scope formation.   If several rules are set, the OR logic applies.
	Matches []MonitoredEntityFilter `json:"matches"`
}

// NewScope instantiates a new Scope object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewScope(entities []string, matches []MonitoredEntityFilter, ) *Scope {
	this := Scope{}
	this.Entities = entities
	this.Matches = matches
	return &this
}

// NewScopeWithDefaults instantiates a new Scope object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewScopeWithDefaults() *Scope {
	this := Scope{}
	return &this
}

// GetEntities returns the Entities field value
func (o *Scope) GetEntities() []string {
	if o == nil  {
		var ret []string
		return ret
	}

	return o.Entities
}

// GetEntitiesOk returns a tuple with the Entities field value
// and a boolean to check if the value has been set.
func (o *Scope) GetEntitiesOk() (*[]string, bool) {
	if o == nil  {
		return nil, false
	}
	return &o.Entities, true
}

// SetEntities sets field value
func (o *Scope) SetEntities(v []string) {
	o.Entities = v
}

// GetMatches returns the Matches field value
func (o *Scope) GetMatches() []MonitoredEntityFilter {
	if o == nil  {
		var ret []MonitoredEntityFilter
		return ret
	}

	return o.Matches
}

// GetMatchesOk returns a tuple with the Matches field value
// and a boolean to check if the value has been set.
func (o *Scope) GetMatchesOk() (*[]MonitoredEntityFilter, bool) {
	if o == nil  {
		return nil, false
	}
	return &o.Matches, true
}

// SetMatches sets field value
func (o *Scope) SetMatches(v []MonitoredEntityFilter) {
	o.Matches = v
}

func (o Scope) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}
	if true {
		toSerialize["entities"] = o.Entities
	}
	if true {
		toSerialize["matches"] = o.Matches
	}
	return json.Marshal(toSerialize)
}

type NullableScope struct {
	value *Scope
	isSet bool
}

func (v NullableScope) Get() *Scope {
	return v.value
}

func (v *NullableScope) Set(val *Scope) {
	v.value = val
	v.isSet = true
}

func (v NullableScope) IsSet() bool {
	return v.isSet
}

func (v *NullableScope) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableScope(val *Scope) *NullableScope {
	return &NullableScope{value: val, isSet: true}
}

func (v NullableScope) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableScope) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


