/*
 * Dynatrace Configuration API
 *
 * Documentation of the Dynatrace Configuration API. Refer to the [help page](https://www.dynatrace.com/support/help/shortlink/config-api) to read about use-cases and examples.  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dynatrace

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ServiceDetectionOpaqueAndExternalWebRequestApiService ServiceDetectionOpaqueAndExternalWebRequestApi service
type ServiceDetectionOpaqueAndExternalWebRequestApiService service

type ApiCreateOpaqueAndExternalWebRequestDetectionRuleRequest struct {
	ctx _context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebRequestApiService
	position *string
	opaqueAndExternalWebRequestRule *OpaqueAndExternalWebRequestRule
}

func (r ApiCreateOpaqueAndExternalWebRequestDetectionRuleRequest) Position(position string) ApiCreateOpaqueAndExternalWebRequestDetectionRuleRequest {
	r.position = &position
	return r
}
func (r ApiCreateOpaqueAndExternalWebRequestDetectionRuleRequest) OpaqueAndExternalWebRequestRule(opaqueAndExternalWebRequestRule OpaqueAndExternalWebRequestRule) ApiCreateOpaqueAndExternalWebRequestDetectionRuleRequest {
	r.opaqueAndExternalWebRequestRule = &opaqueAndExternalWebRequestRule
	return r
}

func (r ApiCreateOpaqueAndExternalWebRequestDetectionRuleRequest) Execute() (EntityShortRepresentation, *_nethttp.Response, error) {
	return r.ApiService.CreateOpaqueAndExternalWebRequestDetectionRuleExecute(r)
}

/*
 * CreateOpaqueAndExternalWebRequestDetectionRule Creates a new service detection rule | maturity=EARLY_ADOPTER
 * The body must not provide an ID as it will be automatically assigned.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateOpaqueAndExternalWebRequestDetectionRuleRequest
 */
func (a *ServiceDetectionOpaqueAndExternalWebRequestApiService) CreateOpaqueAndExternalWebRequestDetectionRule(ctx _context.Context) ApiCreateOpaqueAndExternalWebRequestDetectionRuleRequest {
	return ApiCreateOpaqueAndExternalWebRequestDetectionRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return EntityShortRepresentation
 */
func (a *ServiceDetectionOpaqueAndExternalWebRequestApiService) CreateOpaqueAndExternalWebRequestDetectionRuleExecute(r ApiCreateOpaqueAndExternalWebRequestDetectionRuleRequest) (EntityShortRepresentation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EntityShortRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebRequestApiService.CreateOpaqueAndExternalWebRequestDetectionRule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_REQUEST"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.position != nil {
		localVarQueryParams.Add("position", parameterToString(*r.position, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opaqueAndExternalWebRequestRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOpaqueAndExternalWebRequestDetectionRuleRequest struct {
	ctx _context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebRequestApiService
	id string
}


func (r ApiDeleteOpaqueAndExternalWebRequestDetectionRuleRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteOpaqueAndExternalWebRequestDetectionRuleExecute(r)
}

/*
 * DeleteOpaqueAndExternalWebRequestDetectionRule Deletes the specified service detection rule | maturity=EARLY_ADOPTER
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the service detection rule to be deleted.
 * @return ApiDeleteOpaqueAndExternalWebRequestDetectionRuleRequest
 */
func (a *ServiceDetectionOpaqueAndExternalWebRequestApiService) DeleteOpaqueAndExternalWebRequestDetectionRule(ctx _context.Context, id string) ApiDeleteOpaqueAndExternalWebRequestDetectionRuleRequest {
	return ApiDeleteOpaqueAndExternalWebRequestDetectionRuleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *ServiceDetectionOpaqueAndExternalWebRequestApiService) DeleteOpaqueAndExternalWebRequestDetectionRuleExecute(r ApiDeleteOpaqueAndExternalWebRequestDetectionRuleRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebRequestApiService.DeleteOpaqueAndExternalWebRequestDetectionRule")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_REQUEST/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetOpaqueAndExternalWebRequestDetectionRuleRequest struct {
	ctx _context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebRequestApiService
	id string
}


func (r ApiGetOpaqueAndExternalWebRequestDetectionRuleRequest) Execute() (OpaqueAndExternalWebRequestRule, *_nethttp.Response, error) {
	return r.ApiService.GetOpaqueAndExternalWebRequestDetectionRuleExecute(r)
}

/*
 * GetOpaqueAndExternalWebRequestDetectionRule Shows the properties of the specified service detection rule | maturity=EARLY_ADOPTER
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the required service detection rule.
 * @return ApiGetOpaqueAndExternalWebRequestDetectionRuleRequest
 */
func (a *ServiceDetectionOpaqueAndExternalWebRequestApiService) GetOpaqueAndExternalWebRequestDetectionRule(ctx _context.Context, id string) ApiGetOpaqueAndExternalWebRequestDetectionRuleRequest {
	return ApiGetOpaqueAndExternalWebRequestDetectionRuleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return OpaqueAndExternalWebRequestRule
 */
func (a *ServiceDetectionOpaqueAndExternalWebRequestApiService) GetOpaqueAndExternalWebRequestDetectionRuleExecute(r ApiGetOpaqueAndExternalWebRequestDetectionRuleRequest) (OpaqueAndExternalWebRequestRule, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OpaqueAndExternalWebRequestRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebRequestApiService.GetOpaqueAndExternalWebRequestDetectionRule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_REQUEST/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOpaqueAndExternalWebRequestDetectionRulesRequest struct {
	ctx _context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebRequestApiService
}


func (r ApiListOpaqueAndExternalWebRequestDetectionRulesRequest) Execute() (StubList, *_nethttp.Response, error) {
	return r.ApiService.ListOpaqueAndExternalWebRequestDetectionRulesExecute(r)
}

/*
 * ListOpaqueAndExternalWebRequestDetectionRules Lists all full web service detection rules | maturity=EARLY_ADOPTER
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListOpaqueAndExternalWebRequestDetectionRulesRequest
 */
func (a *ServiceDetectionOpaqueAndExternalWebRequestApiService) ListOpaqueAndExternalWebRequestDetectionRules(ctx _context.Context) ApiListOpaqueAndExternalWebRequestDetectionRulesRequest {
	return ApiListOpaqueAndExternalWebRequestDetectionRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return StubList
 */
func (a *ServiceDetectionOpaqueAndExternalWebRequestApiService) ListOpaqueAndExternalWebRequestDetectionRulesExecute(r ApiListOpaqueAndExternalWebRequestDetectionRulesRequest) (StubList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  StubList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebRequestApiService.ListOpaqueAndExternalWebRequestDetectionRules")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_REQUEST"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderOpaqueAndExternalWebRequestDetectionRulesRequest struct {
	ctx _context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebRequestApiService
	stubList *StubList
}

func (r ApiOrderOpaqueAndExternalWebRequestDetectionRulesRequest) StubList(stubList StubList) ApiOrderOpaqueAndExternalWebRequestDetectionRulesRequest {
	r.stubList = &stubList
	return r
}

func (r ApiOrderOpaqueAndExternalWebRequestDetectionRulesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.OrderOpaqueAndExternalWebRequestDetectionRulesExecute(r)
}

/*
 * OrderOpaqueAndExternalWebRequestDetectionRules Reorders the service detection rules of the specified type | maturity=EARLY_ADOPTER
 * The request reorders the rules of the specified type according to the order of the IDs in the body of the request. 

 Rules that are omitted in the body of the request will retain their relative order but will be placed *after* all those present in the request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiOrderOpaqueAndExternalWebRequestDetectionRulesRequest
 */
func (a *ServiceDetectionOpaqueAndExternalWebRequestApiService) OrderOpaqueAndExternalWebRequestDetectionRules(ctx _context.Context) ApiOrderOpaqueAndExternalWebRequestDetectionRulesRequest {
	return ApiOrderOpaqueAndExternalWebRequestDetectionRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *ServiceDetectionOpaqueAndExternalWebRequestApiService) OrderOpaqueAndExternalWebRequestDetectionRulesExecute(r ApiOrderOpaqueAndExternalWebRequestDetectionRulesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebRequestApiService.OrderOpaqueAndExternalWebRequestDetectionRules")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_REQUEST/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stubList
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateOpaqueAndExternalWebRequestDetectionRuleRequest struct {
	ctx _context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebRequestApiService
	id string
	opaqueAndExternalWebRequestRule *OpaqueAndExternalWebRequestRule
}

func (r ApiUpdateOpaqueAndExternalWebRequestDetectionRuleRequest) OpaqueAndExternalWebRequestRule(opaqueAndExternalWebRequestRule OpaqueAndExternalWebRequestRule) ApiUpdateOpaqueAndExternalWebRequestDetectionRuleRequest {
	r.opaqueAndExternalWebRequestRule = &opaqueAndExternalWebRequestRule
	return r
}

func (r ApiUpdateOpaqueAndExternalWebRequestDetectionRuleRequest) Execute() (EntityShortRepresentation, *_nethttp.Response, error) {
	return r.ApiService.UpdateOpaqueAndExternalWebRequestDetectionRuleExecute(r)
}

/*
 * UpdateOpaqueAndExternalWebRequestDetectionRule Updates an existing service detection rule | maturity=EARLY_ADOPTER
 * If the rule with the specified ID doesn't exist, a new rule will be created and appended to the end of the rule list. 

 The request keeps an existing order of rules, unless the **order** parameter is set.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the rule to be updated.
 * @return ApiUpdateOpaqueAndExternalWebRequestDetectionRuleRequest
 */
func (a *ServiceDetectionOpaqueAndExternalWebRequestApiService) UpdateOpaqueAndExternalWebRequestDetectionRule(ctx _context.Context, id string) ApiUpdateOpaqueAndExternalWebRequestDetectionRuleRequest {
	return ApiUpdateOpaqueAndExternalWebRequestDetectionRuleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return EntityShortRepresentation
 */
func (a *ServiceDetectionOpaqueAndExternalWebRequestApiService) UpdateOpaqueAndExternalWebRequestDetectionRuleExecute(r ApiUpdateOpaqueAndExternalWebRequestDetectionRuleRequest) (EntityShortRepresentation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EntityShortRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebRequestApiService.UpdateOpaqueAndExternalWebRequestDetectionRule")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_REQUEST/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opaqueAndExternalWebRequestRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateCreateOpaqueAndExternalWebRequestDetectionRuleRequest struct {
	ctx _context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebRequestApiService
	opaqueAndExternalWebRequestRule *OpaqueAndExternalWebRequestRule
}

func (r ApiValidateCreateOpaqueAndExternalWebRequestDetectionRuleRequest) OpaqueAndExternalWebRequestRule(opaqueAndExternalWebRequestRule OpaqueAndExternalWebRequestRule) ApiValidateCreateOpaqueAndExternalWebRequestDetectionRuleRequest {
	r.opaqueAndExternalWebRequestRule = &opaqueAndExternalWebRequestRule
	return r
}

func (r ApiValidateCreateOpaqueAndExternalWebRequestDetectionRuleRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ValidateCreateOpaqueAndExternalWebRequestDetectionRuleExecute(r)
}

/*
 * ValidateCreateOpaqueAndExternalWebRequestDetectionRule Validates the payload for the `POST /ruleBasedServiceDetection/OPAQUE_AND_EXTERNAL_WEB_REQUEST` request | maturity=EARLY_ADOPTER
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiValidateCreateOpaqueAndExternalWebRequestDetectionRuleRequest
 */
func (a *ServiceDetectionOpaqueAndExternalWebRequestApiService) ValidateCreateOpaqueAndExternalWebRequestDetectionRule(ctx _context.Context) ApiValidateCreateOpaqueAndExternalWebRequestDetectionRuleRequest {
	return ApiValidateCreateOpaqueAndExternalWebRequestDetectionRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *ServiceDetectionOpaqueAndExternalWebRequestApiService) ValidateCreateOpaqueAndExternalWebRequestDetectionRuleExecute(r ApiValidateCreateOpaqueAndExternalWebRequestDetectionRuleRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebRequestApiService.ValidateCreateOpaqueAndExternalWebRequestDetectionRule")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_REQUEST/validator"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.opaqueAndExternalWebRequestRule == nil {
		return nil, reportError("opaqueAndExternalWebRequestRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opaqueAndExternalWebRequestRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidateUpdateOpaqueAndExternalWebRequestDetectionRuleRequest struct {
	ctx _context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebRequestApiService
	id string
	opaqueAndExternalWebRequestRule *OpaqueAndExternalWebRequestRule
}

func (r ApiValidateUpdateOpaqueAndExternalWebRequestDetectionRuleRequest) OpaqueAndExternalWebRequestRule(opaqueAndExternalWebRequestRule OpaqueAndExternalWebRequestRule) ApiValidateUpdateOpaqueAndExternalWebRequestDetectionRuleRequest {
	r.opaqueAndExternalWebRequestRule = &opaqueAndExternalWebRequestRule
	return r
}

func (r ApiValidateUpdateOpaqueAndExternalWebRequestDetectionRuleRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ValidateUpdateOpaqueAndExternalWebRequestDetectionRuleExecute(r)
}

/*
 * ValidateUpdateOpaqueAndExternalWebRequestDetectionRule Validate the payload for the `PUT /ruleBasedServiceDetection/OPAQUE_AND_EXTERNAL_WEB_REQUEST/{id}` request | maturity=EARLY_ADOPTER
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the service detection rule to be validated.
 * @return ApiValidateUpdateOpaqueAndExternalWebRequestDetectionRuleRequest
 */
func (a *ServiceDetectionOpaqueAndExternalWebRequestApiService) ValidateUpdateOpaqueAndExternalWebRequestDetectionRule(ctx _context.Context, id string) ApiValidateUpdateOpaqueAndExternalWebRequestDetectionRuleRequest {
	return ApiValidateUpdateOpaqueAndExternalWebRequestDetectionRuleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *ServiceDetectionOpaqueAndExternalWebRequestApiService) ValidateUpdateOpaqueAndExternalWebRequestDetectionRuleExecute(r ApiValidateUpdateOpaqueAndExternalWebRequestDetectionRuleRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebRequestApiService.ValidateUpdateOpaqueAndExternalWebRequestDetectionRule")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_REQUEST/{id}/validator"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.opaqueAndExternalWebRequestRule == nil {
		return nil, reportError("opaqueAndExternalWebRequestRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opaqueAndExternalWebRequestRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
