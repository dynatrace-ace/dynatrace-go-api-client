/*
 * Dynatrace Configuration API
 *
 * Documentation of the Dynatrace Configuration API. Refer to the [help page](https://www.dynatrace.com/support/help/shortlink/config-api) to read about use-cases and examples.  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * API version: 1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package dynatrace

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// MobileDeobfuscationAndSymbolicationApiService MobileDeobfuscationAndSymbolicationApi service
type MobileDeobfuscationAndSymbolicationApiService service

// CreateOrUpdateOpts Optional parameters for the method 'CreateOrUpdate'
type CreateOrUpdateOpts struct {
    ContentType optional.String
}

/*
CreateOrUpdate Upload a symbolication file. Either a ProGuard file for Android or a zip file containing all the iOS dSYM files. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId The application id used in Dynatrace of the app this file belongs to
 * @param packageName The CFBundleIdentifier (iOS) or the package name (Android) which identifies the app associated with the uploaded file
 * @param os The operating system the file belongs to
 * @param versionCode The version code (Android) / CFBundleVersion (iOS) the file belongs to
 * @param versionName The version name (Android) / CFBundleShortVersionString (iOS) the file belongs to
 * @param body The file to be uploaded. A proguard file (*.txt) for Android or the zip file produced by the DTXDSSClient provided with the OneAgent for iOS. 
 * @param optional nil or *CreateOrUpdateOpts - Optional Parameters:
 * @param "ContentType" (optional.String) - 
*/
func (a *MobileDeobfuscationAndSymbolicationApiService) CreateOrUpdate(ctx _context.Context, applicationId string, packageName string, os string, versionCode string, versionName string, body *os.File, localVarOptionals *CreateOrUpdateOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/symfiles/{applicationId}/{packageName}/{os}/{versionCode}/{versionName}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(applicationId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"packageName"+"}", _neturl.QueryEscape(parameterToString(packageName, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"os"+"}", _neturl.QueryEscape(parameterToString(os, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"versionCode"+"}", _neturl.QueryEscape(parameterToString(versionCode, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"versionName"+"}", _neturl.QueryEscape(parameterToString(versionName, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(packageName) < 1 {
		return nil, reportError("packageName must have at least 1 elements")
	}
	if strlen(packageName) > 2147483647 {
		return nil, reportError("packageName must have less than 2147483647 elements")
	}
	if strlen(versionCode) < 1 {
		return nil, reportError("versionCode must have at least 1 elements")
	}
	if strlen(versionCode) > 2147483647 {
		return nil, reportError("versionCode must have less than 2147483647 elements")
	}
	if strlen(versionName) < 1 {
		return nil, reportError("versionName must have at least 1 elements")
	}
	if strlen(versionName) > 2147483647 {
		return nil, reportError("versionName must have less than 2147483647 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-compressed", "application/x-zip-compressed", "application/zip", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ContentType.IsSet() {
		localVarHeaderParams["content-type"] = parameterToString(localVarOptionals.ContentType.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// CreateOrUpdatePinningOpts Optional parameters for the method 'CreateOrUpdatePinning'
type CreateOrUpdatePinningOpts struct {
    SymbolFilePinning optional.Interface
}

/*
CreateOrUpdatePinning Pin or unpin all symbolication files of a app version. A pinned file will not be deleted automtically, when running out of space.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId The application id used in Dynatrace of the app which should be (un)pinned
 * @param packageName The CFBundleIdentifier (iOS) or the package name (Android) which identifies the app associated with the files to be (un)pinned
 * @param os The operating system for which the files will be (un)pinned
 * @param versionCode The version code (Android) / CFBundleVersion (iOS) the file belongs to
 * @param versionName The version name (Android) / CFBundleShortVersionString (iOS) the file belongs to
 * @param optional nil or *CreateOrUpdatePinningOpts - Optional Parameters:
 * @param "SymbolFilePinning" (optional.Interface of SymbolFilePinning) -  JSON body of the request, containing the pinning status to set.
*/
func (a *MobileDeobfuscationAndSymbolicationApiService) CreateOrUpdatePinning(ctx _context.Context, applicationId string, packageName string, os string, versionCode string, versionName string, localVarOptionals *CreateOrUpdatePinningOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/symfiles/{applicationId}/{packageName}/{os}/{versionCode}/{versionName}/pinning"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(applicationId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"packageName"+"}", _neturl.QueryEscape(parameterToString(packageName, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"os"+"}", _neturl.QueryEscape(parameterToString(os, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"versionCode"+"}", _neturl.QueryEscape(parameterToString(versionCode, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"versionName"+"}", _neturl.QueryEscape(parameterToString(versionName, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(packageName) < 1 {
		return nil, reportError("packageName must have at least 1 elements")
	}
	if strlen(packageName) > 2147483647 {
		return nil, reportError("packageName must have less than 2147483647 elements")
	}
	if strlen(versionCode) < 1 {
		return nil, reportError("versionCode must have at least 1 elements")
	}
	if strlen(versionCode) > 2147483647 {
		return nil, reportError("versionCode must have less than 2147483647 elements")
	}
	if strlen(versionName) < 1 {
		return nil, reportError("versionName must have at least 1 elements")
	}
	if strlen(versionName) > 2147483647 {
		return nil, reportError("versionName must have less than 2147483647 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.SymbolFilePinning.IsSet() {
		localVarOptionalSymbolFilePinning, localVarOptionalSymbolFilePinningok := localVarOptionals.SymbolFilePinning.Value().(SymbolFilePinning)
		if !localVarOptionalSymbolFilePinningok {
			return nil, reportError("symbolFilePinning should be SymbolFilePinning")
		}
		localVarPostBody = &localVarOptionalSymbolFilePinning
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
DeleteApp Deletes all symbolication file belonging to the Dynatrace App specified
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId The application id used in Dynatrace of the mobile application the files will be deleted
*/
func (a *MobileDeobfuscationAndSymbolicationApiService) DeleteApp(ctx _context.Context, applicationId string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/symfiles/{applicationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(applicationId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
DeleteSingleFile Delete the symbolication file belonging to the given application, os and version
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId The application id used in Dynatrace of the mobile application where a file should be deleted
 * @param packageName The CFBundleIdentifier (iOS) or the package name (Android) which identifies the app associated with the file to be deleted
 * @param os The operating system the file belongs to
 * @param versionCode The version code (Android) / CFBundleVersion (iOS) of the file to be deleted
 * @param versionName The version name (Android) / CFBundleShortVersionString (iOS) of the file to be deleted
*/
func (a *MobileDeobfuscationAndSymbolicationApiService) DeleteSingleFile(ctx _context.Context, applicationId string, packageName string, os string, versionCode string, versionName string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/symfiles/{applicationId}/{packageName}/{os}/{versionCode}/{versionName}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(applicationId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"packageName"+"}", _neturl.QueryEscape(parameterToString(packageName, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"os"+"}", _neturl.QueryEscape(parameterToString(os, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"versionCode"+"}", _neturl.QueryEscape(parameterToString(versionCode, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"versionName"+"}", _neturl.QueryEscape(parameterToString(versionName, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(packageName) < 1 {
		return nil, reportError("packageName must have at least 1 elements")
	}
	if strlen(packageName) > 2147483647 {
		return nil, reportError("packageName must have less than 2147483647 elements")
	}
	if strlen(versionCode) < 1 {
		return nil, reportError("versionCode must have at least 1 elements")
	}
	if strlen(versionCode) > 2147483647 {
		return nil, reportError("versionCode must have less than 2147483647 elements")
	}
	if strlen(versionName) < 1 {
		return nil, reportError("versionName must have at least 1 elements")
	}
	if strlen(versionName) > 2147483647 {
		return nil, reportError("versionName must have less than 2147483647 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
GetAll Lists the metadata of all symbolication files (ProGuard files for Android or dSYM files for iOS Apps) from the Symbol File Store.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return SymbolFileList
*/
func (a *MobileDeobfuscationAndSymbolicationApiService) GetAll(ctx _context.Context) (SymbolFileList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SymbolFileList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/symfiles"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetAllPerApplication Lists the metadata of all symbolication files (ProGuard files for Android or dSYM files for iOS Apps) for one single mobile application from the Symbol File Store of this tenant.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId The application id used in Dynatrace for the mobile application to be queried
@return SymbolFileList
*/
func (a *MobileDeobfuscationAndSymbolicationApiService) GetAllPerApplication(ctx _context.Context, applicationId string) (SymbolFileList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SymbolFileList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/symfiles/{applicationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(applicationId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetInfo Retrieves information about used/empty diskspace, number of stored files,....
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return SymbolFileStorageInfo
*/
func (a *MobileDeobfuscationAndSymbolicationApiService) GetInfo(ctx _context.Context) (SymbolFileStorageInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SymbolFileStorageInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/symfiles/info"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetSingle Gets the metadata of the symbolication file belonging to the specified app version. There always can exist only one file per os and version
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId The application id used in Dynatrace for the mobile application to be queried
 * @param packageName The CFBundleIdentifier (iOS) or the package name (Android) which identifies the app to be queried
 * @param os The operating system for which the file should be displayed.
 * @param versionCode The version code (Android) / CFBundleVersion (iOS) of the file to be retrieved
 * @param versionName The version name (Android) / CFBundleShortVersionString (iOS) of the file to be retrieved
@return SymbolFile
*/
func (a *MobileDeobfuscationAndSymbolicationApiService) GetSingle(ctx _context.Context, applicationId string, packageName string, os string, versionCode string, versionName string) (SymbolFile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SymbolFile
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/symfiles/{applicationId}/{packageName}/{os}/{versionCode}/{versionName}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(applicationId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"packageName"+"}", _neturl.QueryEscape(parameterToString(packageName, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"os"+"}", _neturl.QueryEscape(parameterToString(os, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"versionCode"+"}", _neturl.QueryEscape(parameterToString(versionCode, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"versionName"+"}", _neturl.QueryEscape(parameterToString(versionName, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(packageName) < 1 {
		return localVarReturnValue, nil, reportError("packageName must have at least 1 elements")
	}
	if strlen(packageName) > 2147483647 {
		return localVarReturnValue, nil, reportError("packageName must have less than 2147483647 elements")
	}
	if strlen(versionCode) < 1 {
		return localVarReturnValue, nil, reportError("versionCode must have at least 1 elements")
	}
	if strlen(versionCode) > 2147483647 {
		return localVarReturnValue, nil, reportError("versionCode must have less than 2147483647 elements")
	}
	if strlen(versionName) < 1 {
		return localVarReturnValue, nil, reportError("versionName must have at least 1 elements")
	}
	if strlen(versionName) > 2147483647 {
		return localVarReturnValue, nil, reportError("versionName must have less than 2147483647 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetSupportedVersion Returns the supported file format version for iOS symbol files.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return SupportedVersion
*/
func (a *MobileDeobfuscationAndSymbolicationApiService) GetSupportedVersion(ctx _context.Context) (SupportedVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SupportedVersion
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/symfiles/ios/supportedversion"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ValidatePinningOpts Optional parameters for the method 'ValidatePinning'
type ValidatePinningOpts struct {
    SymbolFilePinning optional.Interface
}

/*
ValidatePinning Validate updates of existing request attribute for the `PUT /{applicationId}/{packageName}/{os}/{versionName}/pinning` request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId The application id used in Dynatrace of the app which should be (un)pinned
 * @param packageName The CFBundleIdentifier (iOS) or the package name (Android) which identifies the app associated with the files to be (un)pinned
 * @param os The operating system for which the files will be (un)pinned
 * @param versionCode The version code (Android) / CFBundleVersion (iOS) the file belongs to
 * @param versionName The version name (Android) / CFBundleShortVersionString (iOS) the file belongs to
 * @param optional nil or *ValidatePinningOpts - Optional Parameters:
 * @param "SymbolFilePinning" (optional.Interface of SymbolFilePinning) -  JSON body of the request, containing the pinning status to set.
*/
func (a *MobileDeobfuscationAndSymbolicationApiService) ValidatePinning(ctx _context.Context, applicationId string, packageName string, os string, versionCode string, versionName string, localVarOptionals *ValidatePinningOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/symfiles/{applicationId}/{packageName}/{os}/{versionCode}/{versionName}/pinning/validator"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(applicationId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"packageName"+"}", _neturl.QueryEscape(parameterToString(packageName, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"os"+"}", _neturl.QueryEscape(parameterToString(os, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"versionCode"+"}", _neturl.QueryEscape(parameterToString(versionCode, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"versionName"+"}", _neturl.QueryEscape(parameterToString(versionName, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(packageName) < 1 {
		return nil, reportError("packageName must have at least 1 elements")
	}
	if strlen(packageName) > 2147483647 {
		return nil, reportError("packageName must have less than 2147483647 elements")
	}
	if strlen(versionCode) < 1 {
		return nil, reportError("versionCode must have at least 1 elements")
	}
	if strlen(versionCode) > 2147483647 {
		return nil, reportError("versionCode must have less than 2147483647 elements")
	}
	if strlen(versionName) < 1 {
		return nil, reportError("versionName must have at least 1 elements")
	}
	if strlen(versionName) > 2147483647 {
		return nil, reportError("versionName must have less than 2147483647 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.SymbolFilePinning.IsSet() {
		localVarOptionalSymbolFilePinning, localVarOptionalSymbolFilePinningok := localVarOptionals.SymbolFilePinning.Value().(SymbolFilePinning)
		if !localVarOptionalSymbolFilePinningok {
			return nil, reportError("symbolFilePinning should be SymbolFilePinning")
		}
		localVarPostBody = &localVarOptionalSymbolFilePinning
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
