/*
 * Dynatrace Configuration API
 *
 * Documentation of the Dynatrace Configuration API. Refer to the [help page](https://www.dynatrace.com/support/help/shortlink/config-api) to read about use-cases and examples.  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dynatrace

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// MobileDeobfuscationAndSymbolicationApiService MobileDeobfuscationAndSymbolicationApi service
type MobileDeobfuscationAndSymbolicationApiService service

type ApiCreateOrUpdateRequest struct {
	ctx _context.Context
	ApiService *MobileDeobfuscationAndSymbolicationApiService
	applicationId string
	packageName string
	os string
	versionCode string
	versionName string
	body **os.File
	contentType *string
}

func (r ApiCreateOrUpdateRequest) Body(body *os.File) ApiCreateOrUpdateRequest {
	r.body = &body
	return r
}
func (r ApiCreateOrUpdateRequest) ContentType(contentType string) ApiCreateOrUpdateRequest {
	r.contentType = &contentType
	return r
}

func (r ApiCreateOrUpdateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateOrUpdateExecute(r)
}

/*
 * CreateOrUpdate Upload a symbolication file. Either a ProGuard file for Android or a zip file containing all the iOS dSYM files. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId The application id used in Dynatrace of the app this file belongs to
 * @param packageName The CFBundleIdentifier (iOS) or the package name (Android) which identifies the app associated with the uploaded file
 * @param os The operating system the file belongs to
 * @param versionCode The version code (Android) / CFBundleVersion (iOS) the file belongs to
 * @param versionName The version name (Android) / CFBundleShortVersionString (iOS) the file belongs to
 * @return ApiCreateOrUpdateRequest
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) CreateOrUpdate(ctx _context.Context, applicationId string, packageName string, os string, versionCode string, versionName string) ApiCreateOrUpdateRequest {
	return ApiCreateOrUpdateRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		packageName: packageName,
		os: os,
		versionCode: versionCode,
		versionName: versionName,
	}
}

/*
 * Execute executes the request
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) CreateOrUpdateExecute(r ApiCreateOrUpdateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MobileDeobfuscationAndSymbolicationApiService.CreateOrUpdate")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/symfiles/{applicationId}/{packageName}/{os}/{versionCode}/{versionName}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.PathEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"packageName"+"}", _neturl.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"os"+"}", _neturl.PathEscape(parameterToString(r.os, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionCode"+"}", _neturl.PathEscape(parameterToString(r.versionCode, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionName"+"}", _neturl.PathEscape(parameterToString(r.versionName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.packageName) < 1 {
		return nil, reportError("packageName must have at least 1 elements")
	}
	if strlen(r.packageName) > 2147483647 {
		return nil, reportError("packageName must have less than 2147483647 elements")
	}
	if strlen(r.versionCode) < 1 {
		return nil, reportError("versionCode must have at least 1 elements")
	}
	if strlen(r.versionCode) > 2147483647 {
		return nil, reportError("versionCode must have less than 2147483647 elements")
	}
	if strlen(r.versionName) < 1 {
		return nil, reportError("versionName must have at least 1 elements")
	}
	if strlen(r.versionName) > 2147483647 {
		return nil, reportError("versionName must have less than 2147483647 elements")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-compressed", "application/x-zip-compressed", "application/zip", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.contentType != nil {
		localVarHeaderParams["content-type"] = parameterToString(*r.contentType, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateOrUpdatePinningRequest struct {
	ctx _context.Context
	ApiService *MobileDeobfuscationAndSymbolicationApiService
	applicationId string
	packageName string
	os string
	versionCode string
	versionName string
	symbolFilePinning *SymbolFilePinning
}

func (r ApiCreateOrUpdatePinningRequest) SymbolFilePinning(symbolFilePinning SymbolFilePinning) ApiCreateOrUpdatePinningRequest {
	r.symbolFilePinning = &symbolFilePinning
	return r
}

func (r ApiCreateOrUpdatePinningRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateOrUpdatePinningExecute(r)
}

/*
 * CreateOrUpdatePinning Pin or unpin all symbolication files of a app version. A pinned file will not be deleted automtically, when running out of space.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId The application id used in Dynatrace of the app which should be (un)pinned
 * @param packageName The CFBundleIdentifier (iOS) or the package name (Android) which identifies the app associated with the files to be (un)pinned
 * @param os The operating system for which the files will be (un)pinned
 * @param versionCode The version code (Android) / CFBundleVersion (iOS) the file belongs to
 * @param versionName The version name (Android) / CFBundleShortVersionString (iOS) the file belongs to
 * @return ApiCreateOrUpdatePinningRequest
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) CreateOrUpdatePinning(ctx _context.Context, applicationId string, packageName string, os string, versionCode string, versionName string) ApiCreateOrUpdatePinningRequest {
	return ApiCreateOrUpdatePinningRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		packageName: packageName,
		os: os,
		versionCode: versionCode,
		versionName: versionName,
	}
}

/*
 * Execute executes the request
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) CreateOrUpdatePinningExecute(r ApiCreateOrUpdatePinningRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MobileDeobfuscationAndSymbolicationApiService.CreateOrUpdatePinning")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/symfiles/{applicationId}/{packageName}/{os}/{versionCode}/{versionName}/pinning"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.PathEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"packageName"+"}", _neturl.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"os"+"}", _neturl.PathEscape(parameterToString(r.os, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionCode"+"}", _neturl.PathEscape(parameterToString(r.versionCode, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionName"+"}", _neturl.PathEscape(parameterToString(r.versionName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.packageName) < 1 {
		return nil, reportError("packageName must have at least 1 elements")
	}
	if strlen(r.packageName) > 2147483647 {
		return nil, reportError("packageName must have less than 2147483647 elements")
	}
	if strlen(r.versionCode) < 1 {
		return nil, reportError("versionCode must have at least 1 elements")
	}
	if strlen(r.versionCode) > 2147483647 {
		return nil, reportError("versionCode must have less than 2147483647 elements")
	}
	if strlen(r.versionName) < 1 {
		return nil, reportError("versionName must have at least 1 elements")
	}
	if strlen(r.versionName) > 2147483647 {
		return nil, reportError("versionName must have less than 2147483647 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.symbolFilePinning
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAppRequest struct {
	ctx _context.Context
	ApiService *MobileDeobfuscationAndSymbolicationApiService
	applicationId string
}


func (r ApiDeleteAppRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteAppExecute(r)
}

/*
 * DeleteApp Deletes all symbolication file belonging to the Dynatrace App specified
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId The application id used in Dynatrace of the mobile application the files will be deleted
 * @return ApiDeleteAppRequest
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) DeleteApp(ctx _context.Context, applicationId string) ApiDeleteAppRequest {
	return ApiDeleteAppRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

/*
 * Execute executes the request
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) DeleteAppExecute(r ApiDeleteAppRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MobileDeobfuscationAndSymbolicationApiService.DeleteApp")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/symfiles/{applicationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.PathEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSingleFileRequest struct {
	ctx _context.Context
	ApiService *MobileDeobfuscationAndSymbolicationApiService
	applicationId string
	packageName string
	os string
	versionCode string
	versionName string
}


func (r ApiDeleteSingleFileRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteSingleFileExecute(r)
}

/*
 * DeleteSingleFile Delete the symbolication file belonging to the given application, os and version
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId The application id used in Dynatrace of the mobile application where a file should be deleted
 * @param packageName The CFBundleIdentifier (iOS) or the package name (Android) which identifies the app associated with the file to be deleted
 * @param os The operating system the file belongs to
 * @param versionCode The version code (Android) / CFBundleVersion (iOS) of the file to be deleted
 * @param versionName The version name (Android) / CFBundleShortVersionString (iOS) of the file to be deleted
 * @return ApiDeleteSingleFileRequest
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) DeleteSingleFile(ctx _context.Context, applicationId string, packageName string, os string, versionCode string, versionName string) ApiDeleteSingleFileRequest {
	return ApiDeleteSingleFileRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		packageName: packageName,
		os: os,
		versionCode: versionCode,
		versionName: versionName,
	}
}

/*
 * Execute executes the request
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) DeleteSingleFileExecute(r ApiDeleteSingleFileRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MobileDeobfuscationAndSymbolicationApiService.DeleteSingleFile")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/symfiles/{applicationId}/{packageName}/{os}/{versionCode}/{versionName}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.PathEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"packageName"+"}", _neturl.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"os"+"}", _neturl.PathEscape(parameterToString(r.os, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionCode"+"}", _neturl.PathEscape(parameterToString(r.versionCode, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionName"+"}", _neturl.PathEscape(parameterToString(r.versionName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.packageName) < 1 {
		return nil, reportError("packageName must have at least 1 elements")
	}
	if strlen(r.packageName) > 2147483647 {
		return nil, reportError("packageName must have less than 2147483647 elements")
	}
	if strlen(r.versionCode) < 1 {
		return nil, reportError("versionCode must have at least 1 elements")
	}
	if strlen(r.versionCode) > 2147483647 {
		return nil, reportError("versionCode must have less than 2147483647 elements")
	}
	if strlen(r.versionName) < 1 {
		return nil, reportError("versionName must have at least 1 elements")
	}
	if strlen(r.versionName) > 2147483647 {
		return nil, reportError("versionName must have less than 2147483647 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllRequest struct {
	ctx _context.Context
	ApiService *MobileDeobfuscationAndSymbolicationApiService
}


func (r ApiGetAllRequest) Execute() (SymbolFileList, *_nethttp.Response, error) {
	return r.ApiService.GetAllExecute(r)
}

/*
 * GetAll Lists the metadata of all symbolication files (ProGuard files for Android or dSYM files for iOS Apps) from the Symbol File Store.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetAllRequest
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) GetAll(ctx _context.Context) ApiGetAllRequest {
	return ApiGetAllRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return SymbolFileList
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) GetAllExecute(r ApiGetAllRequest) (SymbolFileList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SymbolFileList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MobileDeobfuscationAndSymbolicationApiService.GetAll")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/symfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllPerApplicationRequest struct {
	ctx _context.Context
	ApiService *MobileDeobfuscationAndSymbolicationApiService
	applicationId string
}


func (r ApiGetAllPerApplicationRequest) Execute() (SymbolFileList, *_nethttp.Response, error) {
	return r.ApiService.GetAllPerApplicationExecute(r)
}

/*
 * GetAllPerApplication Lists the metadata of all symbolication files (ProGuard files for Android or dSYM files for iOS Apps) for one single mobile application from the Symbol File Store of this tenant.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId The application id used in Dynatrace for the mobile application to be queried
 * @return ApiGetAllPerApplicationRequest
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) GetAllPerApplication(ctx _context.Context, applicationId string) ApiGetAllPerApplicationRequest {
	return ApiGetAllPerApplicationRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
	}
}

/*
 * Execute executes the request
 * @return SymbolFileList
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) GetAllPerApplicationExecute(r ApiGetAllPerApplicationRequest) (SymbolFileList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SymbolFileList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MobileDeobfuscationAndSymbolicationApiService.GetAllPerApplication")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/symfiles/{applicationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.PathEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDssClientUrlRequest struct {
	ctx _context.Context
	ApiService *MobileDeobfuscationAndSymbolicationApiService
}


func (r ApiGetDssClientUrlRequest) Execute() (SymbolFileClientLinkDto, *_nethttp.Response, error) {
	return r.ApiService.GetDssClientUrlExecute(r)
}

/*
 * GetDssClientUrl Gets a download link for the latest version of the DTXDSSClient.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetDssClientUrlRequest
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) GetDssClientUrl(ctx _context.Context) ApiGetDssClientUrlRequest {
	return ApiGetDssClientUrlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return SymbolFileClientLinkDto
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) GetDssClientUrlExecute(r ApiGetDssClientUrlRequest) (SymbolFileClientLinkDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SymbolFileClientLinkDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MobileDeobfuscationAndSymbolicationApiService.GetDssClientUrl")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/symfiles/dtxdss-download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInfoRequest struct {
	ctx _context.Context
	ApiService *MobileDeobfuscationAndSymbolicationApiService
}


func (r ApiGetInfoRequest) Execute() (SymbolFileStorageInfo, *_nethttp.Response, error) {
	return r.ApiService.GetInfoExecute(r)
}

/*
 * GetInfo Retrieves information about used/empty diskspace, number of stored files,....
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetInfoRequest
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) GetInfo(ctx _context.Context) ApiGetInfoRequest {
	return ApiGetInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return SymbolFileStorageInfo
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) GetInfoExecute(r ApiGetInfoRequest) (SymbolFileStorageInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SymbolFileStorageInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MobileDeobfuscationAndSymbolicationApiService.GetInfo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/symfiles/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSingleRequest struct {
	ctx _context.Context
	ApiService *MobileDeobfuscationAndSymbolicationApiService
	applicationId string
	packageName string
	os string
	versionCode string
	versionName string
}


func (r ApiGetSingleRequest) Execute() (SymbolFile, *_nethttp.Response, error) {
	return r.ApiService.GetSingleExecute(r)
}

/*
 * GetSingle Gets the metadata of the symbolication file belonging to the specified app version. There always can exist only one file per os and version
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId The application id used in Dynatrace for the mobile application to be queried
 * @param packageName The CFBundleIdentifier (iOS) or the package name (Android) which identifies the app to be queried
 * @param os The operating system for which the file should be displayed.
 * @param versionCode The version code (Android) / CFBundleVersion (iOS) of the file to be retrieved
 * @param versionName The version name (Android) / CFBundleShortVersionString (iOS) of the file to be retrieved
 * @return ApiGetSingleRequest
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) GetSingle(ctx _context.Context, applicationId string, packageName string, os string, versionCode string, versionName string) ApiGetSingleRequest {
	return ApiGetSingleRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		packageName: packageName,
		os: os,
		versionCode: versionCode,
		versionName: versionName,
	}
}

/*
 * Execute executes the request
 * @return SymbolFile
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) GetSingleExecute(r ApiGetSingleRequest) (SymbolFile, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SymbolFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MobileDeobfuscationAndSymbolicationApiService.GetSingle")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/symfiles/{applicationId}/{packageName}/{os}/{versionCode}/{versionName}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.PathEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"packageName"+"}", _neturl.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"os"+"}", _neturl.PathEscape(parameterToString(r.os, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionCode"+"}", _neturl.PathEscape(parameterToString(r.versionCode, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionName"+"}", _neturl.PathEscape(parameterToString(r.versionName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.packageName) < 1 {
		return localVarReturnValue, nil, reportError("packageName must have at least 1 elements")
	}
	if strlen(r.packageName) > 2147483647 {
		return localVarReturnValue, nil, reportError("packageName must have less than 2147483647 elements")
	}
	if strlen(r.versionCode) < 1 {
		return localVarReturnValue, nil, reportError("versionCode must have at least 1 elements")
	}
	if strlen(r.versionCode) > 2147483647 {
		return localVarReturnValue, nil, reportError("versionCode must have less than 2147483647 elements")
	}
	if strlen(r.versionName) < 1 {
		return localVarReturnValue, nil, reportError("versionName must have at least 1 elements")
	}
	if strlen(r.versionName) > 2147483647 {
		return localVarReturnValue, nil, reportError("versionName must have less than 2147483647 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSupportedVersionRequest struct {
	ctx _context.Context
	ApiService *MobileDeobfuscationAndSymbolicationApiService
}


func (r ApiGetSupportedVersionRequest) Execute() (SupportedVersion, *_nethttp.Response, error) {
	return r.ApiService.GetSupportedVersionExecute(r)
}

/*
 * GetSupportedVersion Returns the supported file format version for iOS symbol files.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetSupportedVersionRequest
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) GetSupportedVersion(ctx _context.Context) ApiGetSupportedVersionRequest {
	return ApiGetSupportedVersionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return SupportedVersion
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) GetSupportedVersionExecute(r ApiGetSupportedVersionRequest) (SupportedVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SupportedVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MobileDeobfuscationAndSymbolicationApiService.GetSupportedVersion")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/symfiles/ios/supportedversion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidatePinningRequest struct {
	ctx _context.Context
	ApiService *MobileDeobfuscationAndSymbolicationApiService
	applicationId string
	packageName string
	os string
	versionCode string
	versionName string
	symbolFilePinning *SymbolFilePinning
}

func (r ApiValidatePinningRequest) SymbolFilePinning(symbolFilePinning SymbolFilePinning) ApiValidatePinningRequest {
	r.symbolFilePinning = &symbolFilePinning
	return r
}

func (r ApiValidatePinningRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ValidatePinningExecute(r)
}

/*
 * ValidatePinning Validate updates of existing request attribute for the `PUT /{applicationId}/{packageName}/{os}/{versionName}/pinning` request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId The application id used in Dynatrace of the app which should be (un)pinned
 * @param packageName The CFBundleIdentifier (iOS) or the package name (Android) which identifies the app associated with the files to be (un)pinned
 * @param os The operating system for which the files will be (un)pinned
 * @param versionCode The version code (Android) / CFBundleVersion (iOS) the file belongs to
 * @param versionName The version name (Android) / CFBundleShortVersionString (iOS) the file belongs to
 * @return ApiValidatePinningRequest
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) ValidatePinning(ctx _context.Context, applicationId string, packageName string, os string, versionCode string, versionName string) ApiValidatePinningRequest {
	return ApiValidatePinningRequest{
		ApiService: a,
		ctx: ctx,
		applicationId: applicationId,
		packageName: packageName,
		os: os,
		versionCode: versionCode,
		versionName: versionName,
	}
}

/*
 * Execute executes the request
 */
func (a *MobileDeobfuscationAndSymbolicationApiService) ValidatePinningExecute(r ApiValidatePinningRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MobileDeobfuscationAndSymbolicationApiService.ValidatePinning")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/symfiles/{applicationId}/{packageName}/{os}/{versionCode}/{versionName}/pinning/validator"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.PathEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"packageName"+"}", _neturl.PathEscape(parameterToString(r.packageName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"os"+"}", _neturl.PathEscape(parameterToString(r.os, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionCode"+"}", _neturl.PathEscape(parameterToString(r.versionCode, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionName"+"}", _neturl.PathEscape(parameterToString(r.versionName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.packageName) < 1 {
		return nil, reportError("packageName must have at least 1 elements")
	}
	if strlen(r.packageName) > 2147483647 {
		return nil, reportError("packageName must have less than 2147483647 elements")
	}
	if strlen(r.versionCode) < 1 {
		return nil, reportError("versionCode must have at least 1 elements")
	}
	if strlen(r.versionCode) > 2147483647 {
		return nil, reportError("versionCode must have less than 2147483647 elements")
	}
	if strlen(r.versionName) < 1 {
		return nil, reportError("versionName must have at least 1 elements")
	}
	if strlen(r.versionName) > 2147483647 {
		return nil, reportError("versionName must have less than 2147483647 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.symbolFilePinning
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
