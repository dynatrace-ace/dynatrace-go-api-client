/*
 * Dynatrace Environment API
 *
 *  Documentation of the Dynatrace Environment API v2. Resources here generally supersede those in v1. Migration of resources from v1 is in progress.   If you miss a resource, consider using the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/2u23k1k) .  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * API version: 2.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dynatrace

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// Extensions20ApiService Extensions20Api service
type Extensions20ApiService service

type ApiActivateExtensionEnvironmentConfigurationRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	extensionName string
	extensionEnvironmentConfigurationVersion *ExtensionEnvironmentConfigurationVersion
}

func (r ApiActivateExtensionEnvironmentConfigurationRequest) ExtensionEnvironmentConfigurationVersion(extensionEnvironmentConfigurationVersion ExtensionEnvironmentConfigurationVersion) ApiActivateExtensionEnvironmentConfigurationRequest {
	r.extensionEnvironmentConfigurationVersion = &extensionEnvironmentConfigurationVersion
	return r
}

func (r ApiActivateExtensionEnvironmentConfigurationRequest) Execute() (ExtensionEnvironmentConfigurationVersion, *_nethttp.Response, error) {
	return r.ApiService.ActivateExtensionEnvironmentConfigurationExecute(r)
}

/*
 * ActivateExtensionEnvironmentConfiguration Activates the environment configuration from the specified version of the extension 2.0
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionName The name of the requested extension 2.0.
 * @return ApiActivateExtensionEnvironmentConfigurationRequest
 */
func (a *Extensions20ApiService) ActivateExtensionEnvironmentConfiguration(ctx _context.Context, extensionName string) ApiActivateExtensionEnvironmentConfigurationRequest {
	return ApiActivateExtensionEnvironmentConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		extensionName: extensionName,
	}
}

/*
 * Execute executes the request
 * @return ExtensionEnvironmentConfigurationVersion
 */
func (a *Extensions20ApiService) ActivateExtensionEnvironmentConfigurationExecute(r ApiActivateExtensionEnvironmentConfigurationRequest) (ExtensionEnvironmentConfigurationVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExtensionEnvironmentConfigurationVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.ActivateExtensionEnvironmentConfiguration")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extensionName}/environmentConfiguration"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionName"+"}", _neturl.PathEscape(parameterToString(r.extensionName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.extensionEnvironmentConfigurationVersion == nil {
		return localVarReturnValue, nil, reportError("extensionEnvironmentConfigurationVersion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.extensionEnvironmentConfigurationVersion
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateMonitoringConfigurationRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	extensionName string
	monitoringConfigurationDto *[]MonitoringConfigurationDto
}

func (r ApiCreateMonitoringConfigurationRequest) MonitoringConfigurationDto(monitoringConfigurationDto []MonitoringConfigurationDto) ApiCreateMonitoringConfigurationRequest {
	r.monitoringConfigurationDto = &monitoringConfigurationDto
	return r
}

func (r ApiCreateMonitoringConfigurationRequest) Execute() ([]MonitoringConfigurationResponse, *_nethttp.Response, error) {
	return r.ApiService.CreateMonitoringConfigurationExecute(r)
}

/*
 * CreateMonitoringConfiguration Creates new monitoring configuration for the specified extension 2.0
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionName The name of the requested extension 2.0.
 * @return ApiCreateMonitoringConfigurationRequest
 */
func (a *Extensions20ApiService) CreateMonitoringConfiguration(ctx _context.Context, extensionName string) ApiCreateMonitoringConfigurationRequest {
	return ApiCreateMonitoringConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		extensionName: extensionName,
	}
}

/*
 * Execute executes the request
 * @return []MonitoringConfigurationResponse
 */
func (a *Extensions20ApiService) CreateMonitoringConfigurationExecute(r ApiCreateMonitoringConfigurationRequest) ([]MonitoringConfigurationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MonitoringConfigurationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.CreateMonitoringConfiguration")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extensionName}/monitoringConfigurations"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionName"+"}", _neturl.PathEscape(parameterToString(r.extensionName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.extensionName) < 1 {
		return localVarReturnValue, nil, reportError("extensionName must have at least 1 elements")
	}
	if r.monitoringConfigurationDto == nil {
		return localVarReturnValue, nil, reportError("monitoringConfigurationDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.monitoringConfigurationDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteEnvironmentConfigurationRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	extensionName string
}


func (r ApiDeleteEnvironmentConfigurationRequest) Execute() (ExtensionEnvironmentConfigurationVersion, *_nethttp.Response, error) {
	return r.ApiService.DeleteEnvironmentConfigurationExecute(r)
}

/*
 * DeleteEnvironmentConfiguration Deactivates the environment configuration of the specified extension 2.0
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionName The name of the requested extension 2.0.
 * @return ApiDeleteEnvironmentConfigurationRequest
 */
func (a *Extensions20ApiService) DeleteEnvironmentConfiguration(ctx _context.Context, extensionName string) ApiDeleteEnvironmentConfigurationRequest {
	return ApiDeleteEnvironmentConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		extensionName: extensionName,
	}
}

/*
 * Execute executes the request
 * @return ExtensionEnvironmentConfigurationVersion
 */
func (a *Extensions20ApiService) DeleteEnvironmentConfigurationExecute(r ApiDeleteEnvironmentConfigurationRequest) (ExtensionEnvironmentConfigurationVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExtensionEnvironmentConfigurationVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.DeleteEnvironmentConfiguration")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extensionName}/environmentConfiguration"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionName"+"}", _neturl.PathEscape(parameterToString(r.extensionName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtensionConfigurationSchemaRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	extensionName string
	extensionVersion string
}


func (r ApiExtensionConfigurationSchemaRequest) Execute() (SchemaDefinitionRestDto, *_nethttp.Response, error) {
	return r.ApiService.ExtensionConfigurationSchemaExecute(r)
}

/*
 * ExtensionConfigurationSchema Gets the configuration schema of the specified version of the extension 2.0
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionName The name of the requested extension 2.0.
 * @param extensionVersion The version of the requested extension 2.0
 * @return ApiExtensionConfigurationSchemaRequest
 */
func (a *Extensions20ApiService) ExtensionConfigurationSchema(ctx _context.Context, extensionName string, extensionVersion string) ApiExtensionConfigurationSchemaRequest {
	return ApiExtensionConfigurationSchemaRequest{
		ApiService: a,
		ctx: ctx,
		extensionName: extensionName,
		extensionVersion: extensionVersion,
	}
}

/*
 * Execute executes the request
 * @return SchemaDefinitionRestDto
 */
func (a *Extensions20ApiService) ExtensionConfigurationSchemaExecute(r ApiExtensionConfigurationSchemaRequest) (SchemaDefinitionRestDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SchemaDefinitionRestDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.ExtensionConfigurationSchema")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extensionName}/{extensionVersion}/schema"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionName"+"}", _neturl.PathEscape(parameterToString(r.extensionName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extensionVersion"+"}", _neturl.PathEscape(parameterToString(r.extensionVersion, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.extensionName) < 1 {
		return localVarReturnValue, nil, reportError("extensionName must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtensionDetailsRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	extensionName string
	extensionVersion string
	accept *string
}

func (r ApiExtensionDetailsRequest) Accept(accept string) ApiExtensionDetailsRequest {
	r.accept = &accept
	return r
}

func (r ApiExtensionDetailsRequest) Execute() (Extension, *_nethttp.Response, error) {
	return r.ApiService.ExtensionDetailsExecute(r)
}

/*
 * ExtensionDetails Gets details of the specified version of the extension 2.0
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionName The name of the requested extension 2.0.
 * @param extensionVersion The version of the requested extension 2.0
 * @return ApiExtensionDetailsRequest
 */
func (a *Extensions20ApiService) ExtensionDetails(ctx _context.Context, extensionName string, extensionVersion string) ApiExtensionDetailsRequest {
	return ApiExtensionDetailsRequest{
		ApiService: a,
		ctx: ctx,
		extensionName: extensionName,
		extensionVersion: extensionVersion,
	}
}

/*
 * Execute executes the request
 * @return Extension
 */
func (a *Extensions20ApiService) ExtensionDetailsExecute(r ApiExtensionDetailsRequest) (Extension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Extension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.ExtensionDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extensionName}/{extensionVersion}"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionName"+"}", _neturl.PathEscape(parameterToString(r.extensionName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extensionVersion"+"}", _neturl.PathEscape(parameterToString(r.extensionVersion, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.extensionName) < 1 {
		return localVarReturnValue, nil, reportError("extensionName must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8", "application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		localVarHeaderParams["Accept"] = parameterToString(*r.accept, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtensionMonitoringConfigurationsRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	extensionName string
	nextPageKey *string
	pageSize *int64
	version *string
	active *bool
}

func (r ApiExtensionMonitoringConfigurationsRequest) NextPageKey(nextPageKey string) ApiExtensionMonitoringConfigurationsRequest {
	r.nextPageKey = &nextPageKey
	return r
}
func (r ApiExtensionMonitoringConfigurationsRequest) PageSize(pageSize int64) ApiExtensionMonitoringConfigurationsRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiExtensionMonitoringConfigurationsRequest) Version(version string) ApiExtensionMonitoringConfigurationsRequest {
	r.version = &version
	return r
}
func (r ApiExtensionMonitoringConfigurationsRequest) Active(active bool) ApiExtensionMonitoringConfigurationsRequest {
	r.active = &active
	return r
}

func (r ApiExtensionMonitoringConfigurationsRequest) Execute() (ExtensionMonitoringConfigurationsList, *_nethttp.Response, error) {
	return r.ApiService.ExtensionMonitoringConfigurationsExecute(r)
}

/*
 * ExtensionMonitoringConfigurations Lists all the monitoring configurations of the specified extension 2.0
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionName The name of the requested extension 2.0.
 * @return ApiExtensionMonitoringConfigurationsRequest
 */
func (a *Extensions20ApiService) ExtensionMonitoringConfigurations(ctx _context.Context, extensionName string) ApiExtensionMonitoringConfigurationsRequest {
	return ApiExtensionMonitoringConfigurationsRequest{
		ApiService: a,
		ctx: ctx,
		extensionName: extensionName,
	}
}

/*
 * Execute executes the request
 * @return ExtensionMonitoringConfigurationsList
 */
func (a *Extensions20ApiService) ExtensionMonitoringConfigurationsExecute(r ApiExtensionMonitoringConfigurationsRequest) (ExtensionMonitoringConfigurationsList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExtensionMonitoringConfigurationsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.ExtensionMonitoringConfigurations")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extensionName}/monitoringConfigurations"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionName"+"}", _neturl.PathEscape(parameterToString(r.extensionName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.extensionName) < 1 {
		return localVarReturnValue, nil, reportError("extensionName must have at least 1 elements")
	}

	if r.nextPageKey != nil {
		localVarQueryParams.Add("nextPageKey", parameterToString(*r.nextPageKey, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.active != nil {
		localVarQueryParams.Add("active", parameterToString(*r.active, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActiveEnvironmentConfigurationRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	extensionName string
}


func (r ApiGetActiveEnvironmentConfigurationRequest) Execute() (ExtensionEnvironmentConfigurationVersion, *_nethttp.Response, error) {
	return r.ApiService.GetActiveEnvironmentConfigurationExecute(r)
}

/*
 * GetActiveEnvironmentConfiguration Gets the active environment configuration version of the specified extension 2.0
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionName The name of the requested extension 2.0.
 * @return ApiGetActiveEnvironmentConfigurationRequest
 */
func (a *Extensions20ApiService) GetActiveEnvironmentConfiguration(ctx _context.Context, extensionName string) ApiGetActiveEnvironmentConfigurationRequest {
	return ApiGetActiveEnvironmentConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		extensionName: extensionName,
	}
}

/*
 * Execute executes the request
 * @return ExtensionEnvironmentConfigurationVersion
 */
func (a *Extensions20ApiService) GetActiveEnvironmentConfigurationExecute(r ApiGetActiveEnvironmentConfigurationRequest) (ExtensionEnvironmentConfigurationVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExtensionEnvironmentConfigurationVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.GetActiveEnvironmentConfiguration")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extensionName}/environmentConfiguration"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionName"+"}", _neturl.PathEscape(parameterToString(r.extensionName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEnvironmentConfigurationEventsRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	extensionName string
}


func (r ApiGetEnvironmentConfigurationEventsRequest) Execute() (ExtensionEventsList, *_nethttp.Response, error) {
	return r.ApiService.GetEnvironmentConfigurationEventsExecute(r)
}

/*
 * GetEnvironmentConfigurationEvents List of the latest extension environment configuration events
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionName The name of the requested extension 2.0.
 * @return ApiGetEnvironmentConfigurationEventsRequest
 */
func (a *Extensions20ApiService) GetEnvironmentConfigurationEvents(ctx _context.Context, extensionName string) ApiGetEnvironmentConfigurationEventsRequest {
	return ApiGetEnvironmentConfigurationEventsRequest{
		ApiService: a,
		ctx: ctx,
		extensionName: extensionName,
	}
}

/*
 * Execute executes the request
 * @return ExtensionEventsList
 */
func (a *Extensions20ApiService) GetEnvironmentConfigurationEventsExecute(r ApiGetEnvironmentConfigurationEventsRequest) (ExtensionEventsList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExtensionEventsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.GetEnvironmentConfigurationEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extensionName}/environmentConfiguration/events"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionName"+"}", _neturl.PathEscape(parameterToString(r.extensionName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExtensionMonitoringConfigurationEventsRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	extensionName string
	configurationId string
}


func (r ApiGetExtensionMonitoringConfigurationEventsRequest) Execute() (ExtensionEventsList, *_nethttp.Response, error) {
	return r.ApiService.GetExtensionMonitoringConfigurationEventsExecute(r)
}

/*
 * GetExtensionMonitoringConfigurationEvents Gets the list of the events linked to specific monitoring configuration
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionName The name of the requested extension 2.0.
 * @param configurationId The ID of the requested monitoring configuration.
 * @return ApiGetExtensionMonitoringConfigurationEventsRequest
 */
func (a *Extensions20ApiService) GetExtensionMonitoringConfigurationEvents(ctx _context.Context, extensionName string, configurationId string) ApiGetExtensionMonitoringConfigurationEventsRequest {
	return ApiGetExtensionMonitoringConfigurationEventsRequest{
		ApiService: a,
		ctx: ctx,
		extensionName: extensionName,
		configurationId: configurationId,
	}
}

/*
 * Execute executes the request
 * @return ExtensionEventsList
 */
func (a *Extensions20ApiService) GetExtensionMonitoringConfigurationEventsExecute(r ApiGetExtensionMonitoringConfigurationEventsRequest) (ExtensionEventsList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExtensionEventsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.GetExtensionMonitoringConfigurationEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extensionName}/monitoringConfigurations/{configurationId}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionName"+"}", _neturl.PathEscape(parameterToString(r.extensionName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configurationId"+"}", _neturl.PathEscape(parameterToString(r.configurationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.extensionName) < 1 {
		return localVarReturnValue, nil, reportError("extensionName must have at least 1 elements")
	}
	if strlen(r.configurationId) < 1 {
		return localVarReturnValue, nil, reportError("configurationId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExtensionMonitoringConfigurationStatusRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	extensionName string
	configurationId string
}


func (r ApiGetExtensionMonitoringConfigurationStatusRequest) Execute() (ExtensionStatusDto, *_nethttp.Response, error) {
	return r.ApiService.GetExtensionMonitoringConfigurationStatusExecute(r)
}

/*
 * GetExtensionMonitoringConfigurationStatus Gets the most recent status of the execution of given monitoring configuration
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionName The name of the requested extension 2.0.
 * @param configurationId The ID of the requested monitoring configuration.
 * @return ApiGetExtensionMonitoringConfigurationStatusRequest
 */
func (a *Extensions20ApiService) GetExtensionMonitoringConfigurationStatus(ctx _context.Context, extensionName string, configurationId string) ApiGetExtensionMonitoringConfigurationStatusRequest {
	return ApiGetExtensionMonitoringConfigurationStatusRequest{
		ApiService: a,
		ctx: ctx,
		extensionName: extensionName,
		configurationId: configurationId,
	}
}

/*
 * Execute executes the request
 * @return ExtensionStatusDto
 */
func (a *Extensions20ApiService) GetExtensionMonitoringConfigurationStatusExecute(r ApiGetExtensionMonitoringConfigurationStatusRequest) (ExtensionStatusDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExtensionStatusDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.GetExtensionMonitoringConfigurationStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extensionName}/monitoringConfigurations/{configurationId}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionName"+"}", _neturl.PathEscape(parameterToString(r.extensionName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configurationId"+"}", _neturl.PathEscape(parameterToString(r.configurationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.extensionName) < 1 {
		return localVarReturnValue, nil, reportError("extensionName must have at least 1 elements")
	}
	if strlen(r.configurationId) < 1 {
		return localVarReturnValue, nil, reportError("configurationId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSchemaFileRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	schemaVersion string
	fileName string
}


func (r ApiGetSchemaFileRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.GetSchemaFileExecute(r)
}

/*
 * GetSchemaFile Gets the extension 2.0 schema file in the specified version
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param schemaVersion The version of the schema.
 * @param fileName The name of the schema file.
 * @return ApiGetSchemaFileRequest
 */
func (a *Extensions20ApiService) GetSchemaFile(ctx _context.Context, schemaVersion string, fileName string) ApiGetSchemaFileRequest {
	return ApiGetSchemaFileRequest{
		ApiService: a,
		ctx: ctx,
		schemaVersion: schemaVersion,
		fileName: fileName,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *Extensions20ApiService) GetSchemaFileExecute(r ApiGetSchemaFileRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.GetSchemaFile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/schemas/{schemaVersion}/{fileName}"
	localVarPath = strings.Replace(localVarPath, "{"+"schemaVersion"+"}", _neturl.PathEscape(parameterToString(r.schemaVersion, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fileName"+"}", _neturl.PathEscape(parameterToString(r.fileName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.fileName) < 1 {
		return localVarReturnValue, nil, reportError("fileName must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListExtensionVersionsRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	extensionName string
	nextPageKey *string
	pageSize *int64
}

func (r ApiListExtensionVersionsRequest) NextPageKey(nextPageKey string) ApiListExtensionVersionsRequest {
	r.nextPageKey = &nextPageKey
	return r
}
func (r ApiListExtensionVersionsRequest) PageSize(pageSize int64) ApiListExtensionVersionsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListExtensionVersionsRequest) Execute() (ExtensionList, *_nethttp.Response, error) {
	return r.ApiService.ListExtensionVersionsExecute(r)
}

/*
 * ListExtensionVersions Lists all versions of the extension 2.0
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionName The name of the requested extension 2.0.
 * @return ApiListExtensionVersionsRequest
 */
func (a *Extensions20ApiService) ListExtensionVersions(ctx _context.Context, extensionName string) ApiListExtensionVersionsRequest {
	return ApiListExtensionVersionsRequest{
		ApiService: a,
		ctx: ctx,
		extensionName: extensionName,
	}
}

/*
 * Execute executes the request
 * @return ExtensionList
 */
func (a *Extensions20ApiService) ListExtensionVersionsExecute(r ApiListExtensionVersionsRequest) (ExtensionList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExtensionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.ListExtensionVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extensionName}"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionName"+"}", _neturl.PathEscape(parameterToString(r.extensionName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.extensionName) < 1 {
		return localVarReturnValue, nil, reportError("extensionName must have at least 1 elements")
	}

	if r.nextPageKey != nil {
		localVarQueryParams.Add("nextPageKey", parameterToString(*r.nextPageKey, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListExtensionsRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	nextPageKey *string
	pageSize *int64
	name *string
}

func (r ApiListExtensionsRequest) NextPageKey(nextPageKey string) ApiListExtensionsRequest {
	r.nextPageKey = &nextPageKey
	return r
}
func (r ApiListExtensionsRequest) PageSize(pageSize int64) ApiListExtensionsRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiListExtensionsRequest) Name(name string) ApiListExtensionsRequest {
	r.name = &name
	return r
}

func (r ApiListExtensionsRequest) Execute() (ExtensionList, *_nethttp.Response, error) {
	return r.ApiService.ListExtensionsExecute(r)
}

/*
 * ListExtensions Lists all the extensions 2.0 available in your environment
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListExtensionsRequest
 */
func (a *Extensions20ApiService) ListExtensions(ctx _context.Context) ApiListExtensionsRequest {
	return ApiListExtensionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ExtensionList
 */
func (a *Extensions20ApiService) ListExtensionsExecute(r ApiListExtensionsRequest) (ExtensionList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExtensionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.ListExtensions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.nextPageKey != nil {
		localVarQueryParams.Add("nextPageKey", parameterToString(*r.nextPageKey, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSchemaFilesRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	schemaVersion string
}


func (r ApiListSchemaFilesRequest) Execute() (SchemaFiles, *_nethttp.Response, error) {
	return r.ApiService.ListSchemaFilesExecute(r)
}

/*
 * ListSchemaFiles Lists all the files available for the specified extension 2.0 schema version
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param schemaVersion The version of the schema.
 * @return ApiListSchemaFilesRequest
 */
func (a *Extensions20ApiService) ListSchemaFiles(ctx _context.Context, schemaVersion string) ApiListSchemaFilesRequest {
	return ApiListSchemaFilesRequest{
		ApiService: a,
		ctx: ctx,
		schemaVersion: schemaVersion,
	}
}

/*
 * Execute executes the request
 * @return SchemaFiles
 */
func (a *Extensions20ApiService) ListSchemaFilesExecute(r ApiListSchemaFilesRequest) (SchemaFiles, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SchemaFiles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.ListSchemaFiles")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/schemas/{schemaVersion}"
	localVarPath = strings.Replace(localVarPath, "{"+"schemaVersion"+"}", _neturl.PathEscape(parameterToString(r.schemaVersion, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSchemasRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
}


func (r ApiListSchemasRequest) Execute() (SchemasList, *_nethttp.Response, error) {
	return r.ApiService.ListSchemasExecute(r)
}

/*
 * ListSchemas Lists all the extension 2.0 schemas versions available in your environment
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListSchemasRequest
 */
func (a *Extensions20ApiService) ListSchemas(ctx _context.Context) ApiListSchemasRequest {
	return ApiListSchemasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return SchemasList
 */
func (a *Extensions20ApiService) ListSchemasExecute(r ApiListSchemasRequest) (SchemasList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SchemasList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.ListSchemas")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/schemas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMonitoringConfigurationDetailsRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	extensionName string
	configurationId string
}


func (r ApiMonitoringConfigurationDetailsRequest) Execute() (ExtensionMonitoringConfiguration, *_nethttp.Response, error) {
	return r.ApiService.MonitoringConfigurationDetailsExecute(r)
}

/*
 * MonitoringConfigurationDetails Gets the details of the specified monitoring configuration
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionName The name of the requested extension 2.0.
 * @param configurationId The ID of the requested monitoring configuration.
 * @return ApiMonitoringConfigurationDetailsRequest
 */
func (a *Extensions20ApiService) MonitoringConfigurationDetails(ctx _context.Context, extensionName string, configurationId string) ApiMonitoringConfigurationDetailsRequest {
	return ApiMonitoringConfigurationDetailsRequest{
		ApiService: a,
		ctx: ctx,
		extensionName: extensionName,
		configurationId: configurationId,
	}
}

/*
 * Execute executes the request
 * @return ExtensionMonitoringConfiguration
 */
func (a *Extensions20ApiService) MonitoringConfigurationDetailsExecute(r ApiMonitoringConfigurationDetailsRequest) (ExtensionMonitoringConfiguration, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExtensionMonitoringConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.MonitoringConfigurationDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extensionName}/monitoringConfigurations/{configurationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionName"+"}", _neturl.PathEscape(parameterToString(r.extensionName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configurationId"+"}", _neturl.PathEscape(parameterToString(r.configurationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.extensionName) < 1 {
		return localVarReturnValue, nil, reportError("extensionName must have at least 1 elements")
	}
	if strlen(r.configurationId) < 1 {
		return localVarReturnValue, nil, reportError("configurationId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveExtensionRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	extensionName string
	extensionVersion string
}


func (r ApiRemoveExtensionRequest) Execute() (Extension, *_nethttp.Response, error) {
	return r.ApiService.RemoveExtensionExecute(r)
}

/*
 * RemoveExtension Deletes the specified version of the extension 2.0
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionName The name of the requested extension 2.0.
 * @param extensionVersion The version of the requested extension 2.0
 * @return ApiRemoveExtensionRequest
 */
func (a *Extensions20ApiService) RemoveExtension(ctx _context.Context, extensionName string, extensionVersion string) ApiRemoveExtensionRequest {
	return ApiRemoveExtensionRequest{
		ApiService: a,
		ctx: ctx,
		extensionName: extensionName,
		extensionVersion: extensionVersion,
	}
}

/*
 * Execute executes the request
 * @return Extension
 */
func (a *Extensions20ApiService) RemoveExtensionExecute(r ApiRemoveExtensionRequest) (Extension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Extension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.RemoveExtension")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extensionName}/{extensionVersion}"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionName"+"}", _neturl.PathEscape(parameterToString(r.extensionName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extensionVersion"+"}", _neturl.PathEscape(parameterToString(r.extensionVersion, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.extensionName) < 1 {
		return localVarReturnValue, nil, reportError("extensionName must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveMonitoringConfigurationRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	extensionName string
	configurationId string
}


func (r ApiRemoveMonitoringConfigurationRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.RemoveMonitoringConfigurationExecute(r)
}

/*
 * RemoveMonitoringConfiguration Deletes the specified monitoring configuration
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionName The name of the requested extension 2.0.
 * @param configurationId The ID of the requested monitoring configuration.
 * @return ApiRemoveMonitoringConfigurationRequest
 */
func (a *Extensions20ApiService) RemoveMonitoringConfiguration(ctx _context.Context, extensionName string, configurationId string) ApiRemoveMonitoringConfigurationRequest {
	return ApiRemoveMonitoringConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		extensionName: extensionName,
		configurationId: configurationId,
	}
}

/*
 * Execute executes the request
 */
func (a *Extensions20ApiService) RemoveMonitoringConfigurationExecute(r ApiRemoveMonitoringConfigurationRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.RemoveMonitoringConfiguration")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extensionName}/monitoringConfigurations/{configurationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionName"+"}", _neturl.PathEscape(parameterToString(r.extensionName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configurationId"+"}", _neturl.PathEscape(parameterToString(r.configurationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.extensionName) < 1 {
		return nil, reportError("extensionName must have at least 1 elements")
	}
	if strlen(r.configurationId) < 1 {
		return nil, reportError("configurationId must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateExtensionEnvironmentConfigurationRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	extensionName string
	extensionEnvironmentConfigurationVersion *ExtensionEnvironmentConfigurationVersion
}

func (r ApiUpdateExtensionEnvironmentConfigurationRequest) ExtensionEnvironmentConfigurationVersion(extensionEnvironmentConfigurationVersion ExtensionEnvironmentConfigurationVersion) ApiUpdateExtensionEnvironmentConfigurationRequest {
	r.extensionEnvironmentConfigurationVersion = &extensionEnvironmentConfigurationVersion
	return r
}

func (r ApiUpdateExtensionEnvironmentConfigurationRequest) Execute() (ExtensionEnvironmentConfigurationVersion, *_nethttp.Response, error) {
	return r.ApiService.UpdateExtensionEnvironmentConfigurationExecute(r)
}

/*
 * UpdateExtensionEnvironmentConfiguration Updates the active environment configuration version of the extension 2.0
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionName The name of the requested extension 2.0.
 * @return ApiUpdateExtensionEnvironmentConfigurationRequest
 */
func (a *Extensions20ApiService) UpdateExtensionEnvironmentConfiguration(ctx _context.Context, extensionName string) ApiUpdateExtensionEnvironmentConfigurationRequest {
	return ApiUpdateExtensionEnvironmentConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		extensionName: extensionName,
	}
}

/*
 * Execute executes the request
 * @return ExtensionEnvironmentConfigurationVersion
 */
func (a *Extensions20ApiService) UpdateExtensionEnvironmentConfigurationExecute(r ApiUpdateExtensionEnvironmentConfigurationRequest) (ExtensionEnvironmentConfigurationVersion, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExtensionEnvironmentConfigurationVersion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.UpdateExtensionEnvironmentConfiguration")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extensionName}/environmentConfiguration"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionName"+"}", _neturl.PathEscape(parameterToString(r.extensionName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.extensionEnvironmentConfigurationVersion == nil {
		return localVarReturnValue, nil, reportError("extensionEnvironmentConfigurationVersion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.extensionEnvironmentConfigurationVersion
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMonitoringConfigurationRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	extensionName string
	configurationId string
	monitoringConfigurationUpdateDto *MonitoringConfigurationUpdateDto
}

func (r ApiUpdateMonitoringConfigurationRequest) MonitoringConfigurationUpdateDto(monitoringConfigurationUpdateDto MonitoringConfigurationUpdateDto) ApiUpdateMonitoringConfigurationRequest {
	r.monitoringConfigurationUpdateDto = &monitoringConfigurationUpdateDto
	return r
}

func (r ApiUpdateMonitoringConfigurationRequest) Execute() (MonitoringConfigurationResponse, *_nethttp.Response, error) {
	return r.ApiService.UpdateMonitoringConfigurationExecute(r)
}

/*
 * UpdateMonitoringConfiguration Updates the specified monitoring configuration
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param extensionName The name of the requested extension 2.0.
 * @param configurationId The ID of the requested monitoring configuration.
 * @return ApiUpdateMonitoringConfigurationRequest
 */
func (a *Extensions20ApiService) UpdateMonitoringConfiguration(ctx _context.Context, extensionName string, configurationId string) ApiUpdateMonitoringConfigurationRequest {
	return ApiUpdateMonitoringConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		extensionName: extensionName,
		configurationId: configurationId,
	}
}

/*
 * Execute executes the request
 * @return MonitoringConfigurationResponse
 */
func (a *Extensions20ApiService) UpdateMonitoringConfigurationExecute(r ApiUpdateMonitoringConfigurationRequest) (MonitoringConfigurationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MonitoringConfigurationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.UpdateMonitoringConfiguration")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions/{extensionName}/monitoringConfigurations/{configurationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"extensionName"+"}", _neturl.PathEscape(parameterToString(r.extensionName, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configurationId"+"}", _neturl.PathEscape(parameterToString(r.configurationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(r.extensionName) < 1 {
		return localVarReturnValue, nil, reportError("extensionName must have at least 1 elements")
	}
	if strlen(r.configurationId) < 1 {
		return localVarReturnValue, nil, reportError("configurationId must have at least 1 elements")
	}
	if r.monitoringConfigurationUpdateDto == nil {
		return localVarReturnValue, nil, reportError("monitoringConfigurationUpdateDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.monitoringConfigurationUpdateDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadExtensionRequest struct {
	ctx _context.Context
	ApiService *Extensions20ApiService
	validateOnly *bool
	body *InlineObject1
}

func (r ApiUploadExtensionRequest) ValidateOnly(validateOnly bool) ApiUploadExtensionRequest {
	r.validateOnly = &validateOnly
	return r
}
func (r ApiUploadExtensionRequest) Body(body InlineObject1) ApiUploadExtensionRequest {
	r.body = &body
	return r
}

func (r ApiUploadExtensionRequest) Execute() (Extension, *_nethttp.Response, error) {
	return r.ApiService.UploadExtensionExecute(r)
}

/*
 * UploadExtension Uploads or verifies a new extension 2.0
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiUploadExtensionRequest
 */
func (a *Extensions20ApiService) UploadExtension(ctx _context.Context) ApiUploadExtensionRequest {
	return ApiUploadExtensionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return Extension
 */
func (a *Extensions20ApiService) UploadExtensionExecute(r ApiUploadExtensionRequest) (Extension, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Extension
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Extensions20ApiService.UploadExtension")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extensions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.validateOnly != nil {
		localVarQueryParams.Add("validateOnly", parameterToString(*r.validateOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
